---
slug: first-blog-post
title: 基于位掩码的权限管理相关思考
authors: [hikarukimi]
tags: [backend]
---
<!--slug表示当前文档对应的url路径,表现为/blog/slug-name-->

# 权限控制机制设计演进与权衡分析

## 引言

之前自己搞腾的小项目里面，基本没有权限控制。这次参与一个比较大型的项目时看见系统设计中权限管理是基于位掩码，而不是角色+权限表的方式，感觉挺有意思的。
因此自己想了一下位掩码方案的优点，缺点。有没有其他方案，其他方案的优缺点又分别是什么。

## 一、平铺式位掩码设计

### 1.1 设计原理

平铺式位掩码是权限控制中最简洁的实现方式之一，其核心思想是使用一个整数的每一位来表示一种独立权限。例如，在64位系统中，一个`u64`类型变量可以表示64种不同的权限，每一位的0/1状态对应权限的禁用/启用。

```rust
let permissions: u64 = 0b1101; // 二进制表示，每位代表一种权限
```

### 1.2 核心问题

尽管实现简单，平铺式位掩码存在以下关键局限：

#### 1.2.1 容量限制
- 64位系统最多只能表示64种权限，当权限数量超过64种时无法扩展。若系统需要65种权限，需要引入新的存储变量，导致设计复杂度增加。

#### 1.2.2 组织性缺失
- 所有权限处于同一层级，无法表达逻辑关系（不能达到管理员权限-增加用户这样的效果）。

#### 1.2.3 维护成本高
- 权限定义需要人工维护文档，记录每一位的含义。
- 新增权限时需查找未使用的位，易出现冲突或遗漏。

#### 1.2.4 批量操作困难
- 无法高效地对某一类权限进行批量操作（如禁用所有财务权限）。

```rust
// 难以一次性禁用所有"财务类"权限
fn disable_finance_perms(perms: u64) -> u64 {
    perms & !(HOW_TO_DEFINE_FINANCE_PERMS?) // 需要手动维护财务权限相关的位掩码信息
}
```

## 二、分层式位掩码改进方案

为解决平铺式位掩码的局限，分层式位掩码通过借鉴计算机网络中的子网划分的思想，将位域空间划分为“组标识”和“权限位”两个维度，实现了权限的结构化管理。

### 2.1 设计原理

分层式位掩码将64位整数划分为两部分：
- **组标识位**：用于区分权限所属的逻辑分组（如系统管理组、财务组、业务组）。
- **权限位**：用于表示组内的具体权限。

常见的划分方式为`[8位组ID | 56位权限]`，可扩展为`[16位组ID | 48位权限]`。

```rust
const PERM_ADMIN_READ: u64 = 0x01_00_0000_0000_0001; // 组0x01 | 权限0x01
```

### 2.2 改进优势

#### 2.2.1 容量扩展
- 理论支持`8组 × 56权限 = 448种`权限，远超平铺式的64种。

#### 2.2.2 结构化组织
- 权限值本身包含分组信息，支持逻辑归类。
- 示例：`0x0201`可直接解析为“业务组(02)的读权限(01)”。

#### 2.2.3 批量操作支持
- 可通过组标识位快速禁用/启用整个组的权限。

```rust
// 禁用整个组
fn disable_group(perms: u64, group: u8) -> u64 {
    perms & !(group << 56) // 通过移位操作定位组标识位
}
```

### 2.3 引入的新问题

#### 2.3.1 权限位冲突
- 不同组的相同权限位无法共存，合并后会丢失来源组信息。

```rust
let p1 = 0x01_0001; // 系统组读权限
let p2 = 0x02_0001; // 业务组读权限
let user = p1 | p2; // 合并后无法区分权限来源组
```

#### 2.3.2 存储膨胀
| 方案   | 单个用户存储量                   |
|--------|---------------------------|
| 平铺式 | 固定8字节（u64）                |
| 分层式 | 需多行存储（需要为每一组权限都提供一行来进行存储） |

#### 2.3.3 计算复杂度增加
- 跨组权限检查需遍历多个组，复杂度从O(1)上升为O(组数量)。

```rust
// 检查"所有组"的读权限
fn has_read_all_groups(perms: Vec<u64>) -> bool {
    perms.iter().all(|p| p & 0x0001 == 0x0001) // 需遍历所有组
}
```

## 三、角色+Role表方案

角色+Role表的方案是很常见的一个技术选型，其核心思想是通过“用户-角色-权限”的三层关系实现权限的间接分配。

### 3.1 设计原理

- **用户（User）**：系统操作者，可关联多个角色。
- **角色（Role）**：权限的集合，如“管理员”“普通用户”。
- **权限（Permission）**：具体操作许可，如“删除用户”“查看订单”。

通过维护`user_role`和`role_permission`两张关联表，实现权限的灵活分配。

### 3.2 与位掩码方案对比

| 维度               | 传统角色表（RBAC）       | 位掩码方案      |
|--------------------|-------------------------|------------|
| **权限检查速度**   | 慢（多表JOIN）           | 快（单字段位运算）  |
| **存储密度**       | 低（多行关联记录）       | 高（单字段压缩存储） |
| **并发控制**       | 需要事务                 | 原子操作（无锁）   |
| **缓存利用率**     | 差（内存碎片多）         | 优（连续内存）    |
| **权限组合操作**   | 复杂（多次SQL）          | 简单（位或/与运算） |
| **动态调整灵活性** | 高（直接改表）           | 中（需重设计位掩码） |

### 3.3 优势与局限

#### 优势：
- **灵活性高**：支持动态调整角色权限。
- **可维护性强**：权限逻辑集中在角色定义，便于管理。

#### 局限：
- **性能开销大**：权限检查需多表JOIN，高频场景下延迟较高。
- **存储效率低**：大量关联记录导致存储冗余。

## 四、总结

### 4.1 方案对比表

| 维度         | 平铺位掩码       | 分层位掩码    | RBAC（角色表）   |
|--------------|------------------|----------|------------------|
| **容量**     | 64种             | 数百种      | 无限制           |
| **组织性**   | 无结构           | 明确分组     | 角色层级         |
| **计算效率** | O(1)             | O(组数量)   | O(JOIN次数)      |
| **适用场景** | 简单固定权限     | 复杂权限系统   | 灵活调整需求高   |

### 4.2 最后一点发现

我后面发现这里的所谓分层式位掩码，基于组和权限的划分，实际上和角色+权限表的设计思路是类似的。只是将权限的分组信息直接嵌入到位掩码中，而不是通过关联表来实现。
因此我觉得分层式位掩码或许可以说是角色+权限表的一个变种。可以由角色和权限表的冗余存储来实现，但相比于此，后续基于位运算的权限检查应该是会更高效的。